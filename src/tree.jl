"""
    MIOTree_defaults(kwargs...)

Contains default MIOTree parameters, and modifies them with kwargs.
"""
function MIOTree_defaults(kwargs...)
    d = Dict(:max_depth => 5,
        :cp => 1e-6,
        :minbucket => 0.01) # in seconds
    if !isempty(kwargs)
        for (key, value) in kwargs
            set_param(d, key, value)
        end
    end
    return d
end

""" 
    generate_binary_tree(root::BinaryNode, max_depth::Int)

Returns all nodes and leaves of a dense binary tree.
"""
function generate_binary_tree(root::BinaryNode, max_depth::Int)
    levs = Dict{Int64, Array{BinaryNode}}(0 => [root])
    nodes = [root]
    for i = 1:max_depth
        idxs = levs[i-1][end].idx .+ collect(1:2^i)
        levs[i] = BinaryNode[]
        for j = 1:length(levs[i-1])
            lc = BinaryNode(idxs[2*j-1])
            leftchild(levs[i-1][j], lc)
            push!(levs[i], lc)
            push!(nodes, lc)
            rc = BinaryNode(idxs[2*j])
            rightchild(levs[i-1][j], rc)
            push!(levs[i], rc)
            push!(nodes, rc)
        end
    end
    return nodes, levs[max_depth]
end
    
@with_kw mutable struct MIOTree
    model::JuMP.Model = JuMP.Model()
    root::BinaryNode = BinaryNode(1)
    params::Dict = MIOTree_defaults()
    classes::Union{Nothing, Array{Any}} = nothing
    nodes::Union{Nothing, Array{BinaryNode}} = nothing
    leaves::Union{Nothing, Array{BinaryNode}} = nothing
end

function build_MIOTree(model::JuMP.Model; kwargs...)
    mt = MIOTree(model = model)
    for item in kwargs
        if item.first == :root
            mt[item.first] = item.second
        elseif item.first in keys(mt.params)
            set_param(mt.params, item.first, item.second)
        end
    end
    mt.nodes, mt.leaves = generate_binary_tree(mt.root, get_param(mt, :max_depth))
    return mt
end
build_MIOTree(model::JuMP.Model) = build_MIOTree(model)
build_MIOTree(; kwargs...) = build_MIOTree(JuMP.Model(); kwargs...)
build_MIOTree(solver::MathOptInterface.OptimizerWithAttributes; kwargs...) =  
    build_MIOTree(JuMP.Model(solver); kwargs...)

get_param(mt::MIOTree, sym::Symbol) = get_param(mt.params, sym)

"""
    set_param(mt::MIOTree, sym::Symbol, val::Any) 

Sets parameters for the MIOTree. Note that parameters that change
tree structure take effect IMMEDIATELY on .nodes, .leaves,
but NOT ON .model.
Model must be regenerated by user via generate_tree_model.
"""
function set_param(mt::MIOTree, sym::Symbol, val::Any) 
    set_param(mt.params, sym, val)
    if sym == :max_depth
        mt.root = BinaryNode(mt.root.idx)
        mt.nodes, mt.leaves = generate_binary_tree(mt.root, val) 
    end
end


"""Returns the leaves in which the data X fall. """
function apply(mt::MIOTree, X::Matrix)
    vals = [] # TODO: initialize empty array instead, based on types of indices in MIOTree. 
    for i = 1:size(X, 1)
        row = X[i,:]
        nd = mt.root
        while !is_leaf(nd)
            lhs = sum(nd.a .* row)
            if lhs ≤ nd.b
                nd = nd.left
            else
                nd = nd.right
            end
        end
        push!(vals, nd.idx)
    end
    return vals
end

""" Makes predictions using a tree, based on data X. """
function predict(mt::MIOTree, X::Matrix)
    vals = [] # TODO: initialize empty array instead, based on types of labels in MIOTree. 
    for i = 1:size(X, 1)
        row = X[i,:]
        nd = mt.root
        while !is_leaf(nd)
            lhs = sum(nd.a .* row)
            if lhs ≤ nd.b
                nd = nd.left
            else
                nd = nd.right
            end
        end
        push!(vals, nd.label)
    end
    return vals
end

""" Makes predictions based on X, using the MIOTree. """
apply(mt::MIOTree, X::DataFrame) = apply(mt, Matrix(X))
# TODO: improve this by making sure that the DataFrame labels are in the right order. 

""" 
Returns the misclassification error of the MIOTree.
"""
function score(mt::MIOTree)
    return sum(JuMP.getvalue.(mt.model[:Lt]))/size(mt.model[:z],1)
end

"""
Returns the number of nonzero hyperplane coefficients of the MIOTree. 
"""
function complexity(mt::MIOTree)
    return sum(JuMP.getvalue.(mt.model[:s]))
end

"""
    populate_nodes!(mt::MIOTree)

Populates the nodes of the MIOTree using 
optimal solution of the MIO problem. 
"""
function populate_nodes!(mt::MIOTree)
    termination_status(mt.model) == MOI.OPTIMAL || 
        throw(ErrorException("MIOTree must be trained before it can be pruned."))
    queue = BinaryNode[mt.root]
    m = mt.model
    while !isempty(queue) # First populate the a,b hyperplane values
        nd = pop!(queue)
        if !is_leaf(nd)
            aval = getvalue.(m[:a][nd.idx, :])
            if sum(isapprox.(aval, zeros(length(aval)); atol = 1e-8)) != length(aval)
                nd.a = aval
                nd.b = getvalue.(m[:b][nd.idx])
                for child in children(nd)
                    push!(queue, child)
                end
            end
        end
    end
    for lf in mt.leaves # Then populate the class values...
        class_values = [isapprox(getvalue.(m[:ckt][i, lf.idx]), 1; atol=1e-8) for i = 1:length(mt.classes)]
        if sum(class_values) == 1
            lf.label = mt.classes[findall(class_values)[1]]
        elseif sum(class_values) > 1
            throw(ErrorException("Multiple classes assigned to node $(lf.idx)."))
        end
    end
    return
end

""" 
    prune!(mt::MIOTree)

Populates and prunes MIOTree, and updates .nodes and .leaves. 
See ```populate_nodes''' for 
how to populate nodes using optimal solution data. 
"""
function prune!(mt::MIOTree)
    leaves = BinaryNode[]
    queue = BinaryNode[mt.root]
    while !isempty(queue)
        nd = pop!(queue)
        if !isnothing(nd.a) && any(nd.a != 0)
            for child in children(nd)
                push!(queue, child)
            end
        else
            alloffspr = alloffspring(nd)
            if isnothing(nd.label)
                alllabels = [nextnode.label for nextnode in alloffspr if !isnothing(nextnode.label)]
                if length(alllabels) == 1 
                    nd.label = alllabels[1]

                elseif length(alllabels) > 1
                    throw(ErrorException("Too many labels below node $(nd.idx)! Bug!"))
                else
                    throw(ErrorException("Missing labels below node $(nd.idx)! Bug!"))
                end
            end
            delete_children!(nd)
            push!(leaves, nd)
        end
    end
    mt.nodes = union([mt.root], alloffspring(mt.root))
    mt.leaves = leaves
    # Add checks here so that the number of branches + leaves == total number of nodes
    return
end